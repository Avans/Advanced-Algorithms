<!DOCTYPE html>
<html>
<head>
  <title>Sorting</title>
</head>

<body>
  <h1>Quicksort &amp; Mergesort</h2>

  <p>Deze week gaan we kijken naar twee van de meest gebruikte sorteeralgoritmes in de 'echte wereld': quicksort en mergesort. Deze worden vaak omschreven als de snelle sorteeralgoritmes die in O(n*log(n)) tijd een lijst kunnen sorteren. Of ze in de praktijk echt sneller zijn gaan we deze week achter komen door ze te maken en te testen. Je mag je laten inspireren door versies van quicksort en mergesort die op het internet staan, maar let op dat ze vaak subtiel van elkaar verschillen en misschien niet 100% van toepassing zijn op de versies die wij van jullie vragen. Altijd weten wat je aan het programmeren bent dus! Het is niet toegestaan om parameters toe te voegen / te veranderen of het return type aan te passen van methodes die we jullie gegeven hebben.</p>

  <a href="https://classroom.github.com/assignment-invitations/2ebbd5e5a3278d3b2d988d0cd0b8d5c2" class="github_link">GitHub: Week 2. Sorting</a>

  <div class="assignment">
    <h2>Quicksort (40pt)</h2>
    <img src="static/img/stopwatch.png" class="right">

    <p>We beginnen met het maken van Quicksort, in het project wat je uit GitHub deze week hebt gekopieerd zit het bestand <code>Quicksort.cs</code>, daar zitten al een aantal methodes in die je op weg helpen. Je methode moet gebruik maken van een klasse SortList, deze stelt de lijst voor die je moet sorteren. Je mag alleen gebruik maken van de methodes <code>Count</code>, <code>swap()</code> en <code>compare()</code>. In de broncode vind je meer informatie over wat deze methodes doen.</p>

    <p>Onze hint is om te beginnen met de <code>partition()</code> methode. Deze neemt als invoer de index van een pivot en een range (leftIndex...rightIndex) die gepartitioneerd dient te worden. Als bijvoorbeeld de volgende SortList wordt gebruikt:</p>

    <table class="table table-bordered" style="font-family: Courier;">
      <tr style="background-color: #eee">
        <th>index</th>
        <th>0</th>
        <th>1</th>
        <th>2</th>
        <th>3</th>
        <th>4</th>
        <th>5</th>
        <th>6</th>
        <th>7</th>
        <th>8</th>
        <th>9</th>
      </tr>
      <tr>
        <th>waarde</th>
        <td>21</td>
        <td>89</td>
        <td>95</td>
        <td>64</td>
        <td>11</td>
        <td>4</td>
        <td>48</td>
        <td>33</td>
        <td>42</td>
        <td>50</td>
      </tr>
    </table>

    <p>Als we vervolgens bijvoorbeeld <code>partition(list, 3, 1, 7)</code> aanroepen betekend dat dat we de lijst van index 1 tot en met 7 gepartitioneerd willen hebben met als pivot de waarde op index 3 (64). Een mogelijke gepartitioneerde lijst zou er zo uit kunnen zien:</p>

    <style>
.outofrange {
  color: #ccc;
}
.low {
  background-color: lightblue;
}
.pivot {
  background-color: lightgreen;
}
.high {
  background-color: pink;
}
    </style>
    <table class="table table-bordered" style="font-family: Courier;">
      <tr style="background-color: #eee">
        <th>index</th>
        <th>0</th>
        <th>1</th>
        <th>2</th>
        <th>3</th>
        <th>4</th>
        <th>5</th>
        <th>6</th>
        <th>7</th>
        <th>8</th>
        <th>9</th>
      </tr>
      <tr>
        <th>waarde</th>
        <td class="outofrange">21</td>
        <td class="low">33</td>
        <td class="low">48</td>
        <td class="low">4</td>
        <td class="low">11</td>
        <td class="pivot">64</td>
        <td class="high">95</td>
        <td class="high">89</td>
        <td class="outofrange">42</td>
        <td class="outofrange">50</td>
      </tr>
    </table>

    <p>De waardes op index 0, 8 en 9 blijven op hun plek staan, want die vallen niet binnen de leftIndex...rightIndex range. Maar de rest wordt flink gehusseld. <span class="low">De vier waardes lager dan de pivot staan nu allemaal links van 64</span>. <span class="pivot">De pivot waarde zelf staat op de enige mogelijke plek waar deze kan komen te staan: index 5</span>. <span class="high">En de twee waardes hoger dan de pivot komen rechts van de pivot te staan</span>. Merk op dat de <em>volgorde</em> van de lage waardes en de hoge waardes niet uit maakt, het gaat er om dat ze links en rechts van de pivot staan. De <b>return waarde</b> van deze aanroep is in dit geval 5, want dat is de nieuwe index geworden van de pivotwaarde</p>

    <p>Als je het partitioneer algoritme afhebt kan je daar gebruik van maken in je <code>quicksort()</code> methode zoals beschreven in de sheets. Let op dat je de pivot zelf niet meer hoeft mee te nemen in de recursieve aanroep.</p>


    <h2>Mergesort (40pt)</h2>

    <p>Voor het maken van <code>mergesort()</code> hoef je geen gebruik te maken van de <code>swap()</code> en <code>compare()</code> methodes in de <code>ISortList</code> interface. Mergesort is geen in-place algoritme dus je mag in je algoritme direct de waardes uit de array lezen en schrijven. Dit kun je doen door een instantie van <code>ISortList</code> te gebruiken alsof het een array is: <code>list[5]</code>. Onze hint is dan ook om gebruik te maken van hulp-arrays waar je vanuit (of naartoe) kunt mergen.</p>

    <p>Net als Quicksort is deze methode een void. Het resultaat van de aanroep is ook niet een concrete returnwaarde, maar wel een resultaat: het gedeelte waarop mergesort is aangeroepen wordt volledig gesorteerd achtergelaten.</p>

    <h2>Wie is de snelste? (20pt)</h2>

    <p><i>2 soorten inputs, 4 algoritmes, 1000 elementen: wie kan het snelst sorteren, met het minst aantal swaps en vergelijkingen?</i></p>

    <p>Deze opdracht is om onderstaande tabel over te nemen en in te vullen. De algoritmes voor quicksort en mergesort heb je als het goed is al geschreven, bubblesort moet je voor deze opdracht nog eventjes schrijven (doe vooral niet teveel moeite en laat je inspireren door internet of door wat je voor ALG1 hebt moeten programmeren.</p>

    <p>We gaan vier algoritmes testen: quicksort, quicksort3, mergesort en bubblesort. Zorg ervoor dat quicksort altijd de meest linkse waarde als de pivot kiest en quicksort3 de mediaan van de eerste, de laatste en de middelste waarde als pivot kiest. Test voor elk algoritme ook twee soorten input: een array van 1000 elementen die al volledig gesorteerd is (te maken met: <code>new SortList(1000, true)</code>, en een array van 1000 elementen die in een random volgorde staan (te maken met: <code>new SortList(1000)</code>).</p>

    <p>Voor elk algoritme en elke input test je de volgende eigenschappen:</p>

    <p>
      <b>Aantal vergelijkingen</b><br>
      Hierbij tel je alle vergelijkingen die je doet tussen elementen van de input. Het gaat dus alleen maar om groter dan / kleiner dan vergelijkingen die te maken hebben met de waardes die in de input array staan. Alle andere vergelijkingen die je doet met bijvoorbeeld lokale variabele hoef je niet mee te tellen. Als je consistent gebruik hebt gemaakt van de <code>compare()</code> methode in ISortList dan kan je deze waarde uitlezen in de property <code>Comparisons</code>. En anders moet je deze even zelf bijhouden.
    </p>

    <p>
      <b>Aantal swaps</b><br>
      Een swap is elke keer als je een waarde wegschrijft in de input array of twee elementen in de input array omdraait. Een waarde wegschrijven in een kopie van de array of in een hulp array telt ook als een swap. Als je alleen waardes hebt geswapt via de <code>swap()</code> methode in ISortList dan kan je het aantal swaps uitlezen via de property <code>Swaps</code>.
    </p>

    <p>
      <b>Uitvoertijd</b><br>
      Dit is hoeveel secondes het algoritme er over doet om te sorteren. Waarschijnlijk zal dit te snel gaan om nauwkeurig te meten. Als je het algoritme een miljoen keer uitvoert en dan de tijd deelt door een miljoen krijg je een nauwkeurige uitkomst.
    </p>

    <p>Vul de resultaten in in het bestand <code>README.md</code>, deze bevat een kopie van onderstaande tabel</p>

    <table class="table table-bordered">
      <tr>
        <th></th>
        <th colspan="2">Quicksort</th>
        <th colspan="2">Quicksort3</th>
        <th colspan="2">Mergesort</th>
        <th colspan="2">Bubblesort</th>
      </tr>
      <tr>
        <th></th>
        <td>gesorteerd</td>
        <td>geshuffled</td>
        <td>gesorteerd</td>
        <td>geshuffled</td>
        <td>gesorteerd</td>
        <td>geshuffled</td>
        <td>gesorteerd</td>
        <td>geshuffled</td>
      </tr>
      <tr>
        <th>Aantal vergelijkingen</th>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <th>Aantal swaps</th>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <th>Uitvoertijd</th>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
    </table>

    <p>Leg kort het verschil tussen de resultaten van quicksort en quicksort3 uit.</p>
  </div>

</body>
</html>
